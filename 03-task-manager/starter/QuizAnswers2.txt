1.In this lesson, you created a middleware function called 
asyncWrapper. Why?

This function designed to handle asynchronous operations from similar route handlers.
We created it to unique prosses and make it more efficient and readable.

2.Suppose that you want to make sure that both a status code and an error message 
are sent back to the user when they request the URL for a task that does not exist. 
Assume that youâ€™ve created a CustomAPIError class and an error handler that references 
that class. Complete the code:

const getTask = asyncWrapper(async (req, res, next) => {  
  const { id: taskID } = req.params;  
  const task = await Task.findOne({ _id: taskID });  
  if (!task) {  
    return next(createCustomError(`No task with id: ${idTask}`,404))  
  }  
  res.status(200).json({ task });  
});  

if CustomErrors.js looks like:

class CustomAPIErrors extends Error{
    constructor(message,statusCode){
        super(message)
        this.statusCode = statusCode
    }
}

const createCustomError = (msg,statusCode) =>{
    return new CustomAPIErrors(msg,statusCode)
}

module.exports = {createCustomError, CustomAPIErrors}